"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("./external/common");
var node_factories_1 = require("./node-factories");
var printers_1 = require("./printers");
function transformCallExpression(callExpr) {
    if (callExpr.property == null)
        return createStringLiteralNodeOrThrow(handleNameof(callExpr));
    if (callExpr.property === "full")
        return createStringLiteralNodeOrThrow(handleNameofFull(callExpr));
    return throwForUnsupportedCallExpression();
    function createStringLiteralNodeOrThrow(value) {
        return value == null ? throwForUnsupportedCallExpression() : node_factories_1.createStringLiteralNode(value);
    }
    function throwForUnsupportedCallExpression() {
        return common_1.throwError("Unsupported nameof call expression: " + printers_1.printCallExpression(callExpr));
    }
}
exports.transformCallExpression = transformCallExpression;
function handleNameof(callExpr) {
    var expression = getExpression();
    return expression == null ? undefined : getNodeAsStringArray(expression, undefined).pop();
    function getExpression() {
        if (callExpr.arguments.length === 1)
            return callExpr.arguments[0];
        else if (callExpr.typeArguments.length === 1)
            return callExpr.typeArguments[0];
        return undefined;
    }
}
function handleNameofFull(callExpr) {
    var exprAndCount = getExpressionAndCount();
    return exprAndCount == null ? undefined : getPartsAsString(getNodeAsStringArray(exprAndCount.expression, undefined), getCount(exprAndCount.count));
    function getExpressionAndCount() {
        if (shouldUseArguments())
            return { expression: callExpr.arguments[0], count: callExpr.arguments.length > 1 ? callExpr.arguments[1] : undefined };
        if (callExpr.typeArguments.length > 0)
            return { expression: callExpr.typeArguments[0], count: callExpr.arguments.length > 0 ? callExpr.arguments[0] : undefined };
        return undefined;
        function shouldUseArguments() {
            if (callExpr.arguments.length === 0)
                return false;
            if (callExpr.typeArguments.length === 0)
                return true;
            return callExpr.arguments[0].kind === "Function";
        }
    }
    function getPartsAsString(parts, count) {
        return getSubParts().join(".");
        function getSubParts() {
            if (count > 0) {
                if (count > parts.length - 1)
                    return common_1.throwError("Count of " + count + " was larger than max count of " + (parts.length - 1) + " for " + printers_1.printCallExpression(callExpr));
                return parts.slice(count);
            }
            if (count < 0) {
                if (Math.abs(count) > parts.length)
                    return common_1.throwError("Count of " + count + " was larger than max count of " + parts.length * -1 + " for " + printers_1.printCallExpression(callExpr));
                return parts.slice(parts.length + count);
            }
            return parts;
        }
    }
    function getCount(countExpr) {
        if (countExpr == null)
            return 0;
        if (countExpr.kind !== "NumericLiteral")
            return common_1.throwError("Expected count to be a number, but was: " + printers_1.printNode(countExpr));
        return countExpr.value;
    }
}
function getNodeAsStringArray(node, parent) {
    var result = [];
    while (node != null) {
        if (node.kind === "Computed") {
            var text = "[" + getNodeAsStringArray(node.value, node).join(".") + "]";
            if (result.length === 0)
                result.push(text);
            else
                result[result.length - 1] += text;
        }
        else if (node.kind === "Function") {
            if (parent != null)
                return common_1.throwError("Nesting functions is not supported: " + printers_1.printNode(node));
            var firstPart = node.value;
            if (firstPart.next == null)
                return common_1.throwError("A property must be accessed on the object: " + printers_1.printNode(node));
            if (firstPart.next.kind === "Computed")
                return common_1.throwError("First accessed property must not be computed: " + printers_1.printNode(node));
            result.push.apply(result, getNodeAsStringArray(firstPart.next, undefined));
        }
        else if (node.kind === "StringLiteral" && parent != null && parent.kind === "Computed" && result.length === 0)
            result.push("\"" + node.value + "\"");
        else if (node.kind === "ArrayLiteral")
            return common_1.throwError("Not implemented transform for ArrayLiteral.");
        else
            result.push(node.value.toString());
        node = node.next;
    }
    return result;
}
